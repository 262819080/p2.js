<!DOCTYPE html>
<html>
<head>
    <title>p2.js</title>
    <script src="../build/p2.js"></script>
    <script src="http://code.jquery.com/jquery-1.10.0.min.js"></script>
    <script src="pixi.js"></script>
    <script src="Demo.js"></script>
    <script src="PixiDemo.js"></script>
    <link href="demo.css" rel="stylesheet"/>
</head>
<body>
    <script>

        var vec2 = p2.vec2;

        var world = new p2.World({
            doProfiling : true,
            gravity : [0,-10],
        });

        world.solver.setSpookParams(1e10,0.1);

        var bodies = [];
        var N=5,
            dt = 1/60,
            k=1000,
            d=10,
            l=0.35,
            m=1;

        // Create particles
        var particleShape = new p2.Particle();
        for(var i=0; i<2*N; i++){
            var p = new p2.Body({
                mass: i==2*N-1 ? 0 : m,
                position : [0, (i-N/2)*l*1.05]
            });

            // Move the rest so one particle position is the same as one other
            if(i>=N)
                p.position[1] -= l*1.05;

            p.addShape(particleShape);
            bodies.push(p);
            world.addBody(p);
        }

        // Springs
        for(var i=0; i<2*N-1; i++){
            var bodyA = bodies[i],
                bodyB = bodies[i+1],
                spring = new p2.Spring(bodyA,bodyB, {
                    stiffness: k,
                    restLength: l,
                    damping : d
                });
            if(i!=N-1)
                world.addSpring(spring);
        }

        var demo = new PixiDemo(world);

        var a = world.solver.a,
            b = world.solver.b,
            G1 =  -1,
            G2 =   1,
            f_lambda1 =  vec2.fromValues(0, 0),
            f_lambda2 =  vec2.fromValues(0, 0),
            dot = vec2.dot,
            epsilon = world.solver.eps;

        function update(){
            if(!demo.paused){

                var i1 = N-1,
                    i2 = N,
                    b1 = world.bodies[i1],
                    b2 = world.bodies[i2],
                    x1 = b1.position[1],
                    x2 = b2.position[1],
                    v1 = b1.velocity[1],
                    v2 = b2.velocity[1],
                    fext = world.gravity[1];

                G1 = -(x2 - x1) / Math.abs(x2 - x1);
                if(isNaN(G1)){
                    G1 = 1;
                }
                G2 = -G1;

                var im1 = getInverseInertia(world,i1,1,G1),
                    im2 = getInverseInertia(world,i2,1,G2);

                // Get external force contribution by stepping without master constraints
                var copy = world.clone();
                copy.step(dt);
                var x1t = x1;
                    x2t = x2;
                    v1t = copy.bodies[i1].velocity[1] - v1,
                    v2t = copy.bodies[i2].velocity[1] - v2;
                var hGiMf = ( G1*v1t + G2*v2t ) * dt;

                var lambda =  ( - a*( G1*x1 + G2*x2 ) + b*( G1*v1 + G2*v2 ) + hGiMf) / ( G1*im1 + G2*im2 + epsilon ) / dt;

                b1.force[1] += G1*lambda;
                b2.force[1] += G2*lambda;

                world.step(dt);
            }

            requestAnimationFrame(update);
        }
        requestAnimationFrame(update);

        function getInverseInertia(world,bodyIndex,dir,G){

            // Get inertia when stepping without external force
            copy = world.clone();
            p = copy.bodies[bodyIndex];
            v0 = p.velocity[dir];
            copy.step(dt);
            var v0 = p.velocity[dir];

            // Get inertia in opposite
            copy = world.clone();
            p = copy.bodies[bodyIndex];
            //v0 = p.velocity[dir];
            p.force[dir] += G; // Add unit force
            copy.step(dt);
            var dv = (p.velocity[dir] - v0);

            // dv is approximately acceleration.
            // f = m*a <=> 1/m = a/f

            return dv/dt;
        }

    </script>
</bodyBody>
</html>
