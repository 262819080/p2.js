<!DOCTYPE html>
<html>
<head>
    <title>p2.js</title>
    <script src="../build/p2.js"></script>
    <script src="http://code.jquery.com/jquery-1.10.0.min.js"></script>
    <script src="pixi.js"></script>
    <script src="Demo.js"></script>
    <script src="PixiDemo.js"></script>
    <link href="demo.css" rel="stylesheet"/>
</head>
<body>
    <script>

        var vec2 = p2.vec2;

        var world = new p2.World({
            doProfiling : true,
            gravity : [0,-10],
        });

        world.solver.setSpookParams(1e22,0.0);

        var bodies = [];
        var N=5,
            dt = 1/60,
            k=1000,
            d=10,
            l=0.35,
            m=1;

        // Create particles
        var particleShape = new p2.Particle();
        for(var i=0; i<2*N; i++){
            var p = new p2.Body({
                mass: i==2*N-1 ? 0 : m,
                position : [0, (i-N/2)*l*1.05]
            });

            // Move the rest so one particle position is the same as one other
            if(i>=N)
                p.position[1] -= l*1.05;

            p.addShape(particleShape);
            bodies.push(p);
            world.addBody(p);
        }

        // Springs
        for(var i=0; i<2*N-1; i++){
            var bodyA = bodies[i],
                bodyB = bodies[i+1],
                spring = new p2.Spring(bodyA,bodyB, {
                    stiffness: k,
                    restLength: l,
                    damping : d
                });
            if(i!=N-1)
                world.addSpring(spring);
        }

        var demo = new PixiDemo(world);

        var a = 1/dt/dt,//world.solver.a,
            b = 1/dt,//world.solver.b,
            d = 0.2,
            G1v = vec2.create(),
            G2v = vec2.create(),
            im1v =  vec2.fromValues(0, 0),
            im2v =  vec2.fromValues(0, 0),
            v1tv =  vec2.fromValues(0, 0),
            v2tv =  vec2.fromValues(0, 0),
            tmp =  vec2.fromValues(0, 0),
            dot = vec2.dot,
            k = 1e10,
            epsilon = 4/(dt*dt*k*(1+4*d));

        function update(){
            if(!demo.paused){

                var i1 = N-1,
                    i2 = N,
                    b1 = world.bodies[i1],
                    b2 = world.bodies[i2],
                    x1v = b1.position,
                    x2v = b2.position,
                    v1v = b1.velocity,
                    v2v = b2.velocity;

                vec2.sub(G1v, x1v, x2v);
                vec2.normalize(G1v,G1v);
                if(vec2.length(G1v) == 0) vec2.set(G1v,0,1);
                vec2.scale(G2v, G1v, -1);

                var im1 = getInverseInertia(world,i1,G1v,im1v),
                    im2 = getInverseInertia(world,i2,G2v,im2v);

                // Get external force contribution by stepping without master constraints
                var copy = world.clone();
                copy.step(dt);

                vec2.sub(v1tv, copy.bodies[i1].velocity, v1v);
                vec2.sub(v2tv, copy.bodies[i2].velocity, v2v);

                var GiMf = ( dot(G1v,v1tv) + dot(G2v,v2tv) );

                var lambda =  ( - (4/dt/dt/(1+4*d))*( dot(G1v,x1v) + dot(G2v,x2v) ) + (1/(1+4*d)-1)/dt*( dot(G1v,v1v) + dot(G2v,v2v)) + GiMf) / ( dot(G1v,im1v) + dot(G2v,im2v) + epsilon );

                vec2.add(b1.force, b1.force, vec2.scale(tmp,G1v,lambda));
                vec2.add(b2.force, b2.force, vec2.scale(tmp,G2v,lambda));

                world.step(dt);
            }

            requestAnimationFrame(update);
        }
        requestAnimationFrame(update);

        var getInverseInertia_dv = vec2.create();
        function getInverseInertia(world,bodyIndex,Gv,out){

            // Get inertia when stepping without external force
            copy = world.clone();
            p = copy.bodies[bodyIndex];
            copy.step(dt);
            var v0v = p.velocity;

            // Get inertia in opposite
            copy = world.clone();
            p = copy.bodies[bodyIndex];
            vec2.add(p.force,p.force,Gv); // Add unit force
            copy.step(dt);

            // dv is approximately acceleration.
            // f = m*a <=> 1/m = a/f
            vec2.sub(getInverseInertia_dv, p.velocity, v0v);
            vec2.scale(out, getInverseInertia_dv, 1/dt);

        }

    </script>
</bodyBody>
</html>
